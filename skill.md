#分布式唯一ID
考虑机器、时间、业务、线程、序列等生成，比如MD5加密后从第8位开始取N位。


#幂等控制
全局幂等和业务幂等

1.1.业务背景
为什么要做全局幂等和业务幂等两重判断？因为系统做了分库分表，全局幂等是为了控制跨库数据，业务幂等是为了控制同库数据。
1.2.表结构
全局幂等表(aqc_pre_global_unique)
主键：request_id
request_id: String(merchantId+merchantTranstionId+bizType)
sharding_key: Hash(request_id)
biz_sharding_key: userid
db_distinguish_key: (true/false)
业务幂等表(aqc_pre_unique)
主键：biz_type+merchant_request_id+merchant_id
1.3.业务流程
1.订单创建时首先往全局幂等表中插入一条记录
2.判断全局幂等表主键是否冲突(request_id)
2.1 如果主键冲突
2.1.1 从全局幂等表中将重复记录查出来
2.1.2 判断查出的记录中分库分表字段(biz_sharding_key)是否与本次请求的相同
2.1.2.1 如果不相同———>则抛参数异常错误
2.1.2.2 如果相同
2.1.2.2.1 从业务幂等表中将重复记录查询出来
2.1.2.2.1.1 判断主键(biz_type+merchant_request_id+merchant_id)是否相同
2.1.2.2.1.1.1 主键冲突———>抛重复请求异常
2.1.2.2.1.1.2 主键不冲突
2.1.2.2.1.1.2.1 继续后续业务流程
2.2 主键不冲突
2.2.1 逐步在全局幂等和业务幂等表中插入本次数据，继续后续业务流程


#孤岛检测
孤岛, 指某个机房与外界的网络断开, 内部还在运作。一般来说, 网络断开, 没有外部流量进来, 这个机房也就不服务了。但是, 一些定时任务、调度系统、批任务等系统还会继续运行, 这时外部可能已经做出容灾切换操作, 可能导致双写。由于外部指令没法到达孤岛机房, 我们期望机房内部感知到自身处于孤岛

#数据访问层并发控制检查
1.单笔更新操作遵循：一锁、二判、三更新的规范
2.批量更新时，确保sql的where字句中存在有原业务流水的状态，且检查更新的记录数目是否符合预期。
3.缓存（线程、本地、分布式）的更新是否能够确保不出现脏数据，缓存更新顺序合理确保数据一致性。
4.状态机设计要完整覆盖状态迁移，特别是对异常的处理


#分布式事务检查
幂等：两阶段原子服务要具有幂等性，以txId作为唯一幂等控制条件，协同主事务和分支事务的幂等。
一致性：事务发起者要谨慎协调参与者的返回，谨慎进行自身回滚/提交操作。
完整性：保证两阶段提交设计的正确性，各阶段执行正确的逻辑，异常情况下可以通过恢复进行正常执行。
回查设计：回查服务要做好防并发，成功、失败、异常情况都能回查，且异常情况下的回查要防止悬挂。
事务悬挂：优先原则要防止误提交/回滚，以免产生资损。


快速落地：
业务：哪些业务，关联，趋势？
技术：哪些技术栈？需要学习什么
流程规章：涉及哪些流程？哪些key person?


#系分如何写？
1、术语
2、需求背景阐述
3、需求分析：实现什么功能，有什么边界约束，哪些是新增，哪些是修改
4、系统以来分析：涉及哪些系统，系统之间如何依赖，出系统架构图
5、业务交互分析：针对各个功能点，分析各系统间的交互时序，改造点，技术风险点，应对方案
6、系统功能接口描述
7、模型设计：涉及什么领域模型,数据模型，状态机变迁





